<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AIと会話</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2 { margin-top: 30px; }
        #record-btn { padding: 1em; font-size: 1.2em; }
        #status, #input-text, #response-text { margin-top: 1em; font-weight: bold; }

        label { font-weight: bold; }
        input { width: 80px; }
        button { margin-top: 10px; padding: 5px 10px; }
        pre { background: #f0f0f0; padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>

    <h1>AIと会話</h1>
    <button id="record-btn">録音開始</button>
    <div id="status">準備完了</div>
    <div id="input-text"></div>
    <div id="response-text"></div>

    <h2>パラメータ設定</h2>
    <form id="jtalkForm">
        <label for="speed">スピード (0.1～2.0):</label><br>
        <input type="number" id="speed" name="speed" step="0.1" min="0.1" max="2.0" value="1.0"><br><br>

        <label for="volume">ボリューム (0.1～10.0):</label><br>
        <input type="number" id="volume" name="volume" step="0.1" min="0.1" max="10.0" value="1.0"><br><br>

        <button type="button" onclick="submitParams()">パラメータ送信</button>
        <pre id="param"></pre>
    </form>

    <h2>会話履歴の初期化</h2>
    <button onclick="resetMessages()">履歴を初期化</button>
    <pre id="initLog"></pre>

    <script>
        const recordBtn = document.getElementById('record-btn');
        const statusDiv = document.getElementById('status');
        const inputTextDiv = document.getElementById('input-text');
        const responseTextDiv = document.getElementById('response-text');
        let mediaRecorder, isRecording = false, audioChunks = [];

        recordBtn.addEventListener('click', () => {
            if (!isRecording) {
                startRecording();
                recordBtn.innerText = '録音停止';
                statusDiv.innerText = '録音中';
                // inputTextDiv.innerText = '';
                // responseTextDiv.innerText = '';
            } else {
                stopRecording();
                recordBtn.innerText = '録音開始';
                statusDiv.innerText = '録音停止中';
            }
            isRecording = !isRecording;
        });

        async function startRecording() {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            audioChunks = [];
            mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);

            mediaRecorder.onstop = async () => {
                const blob = new Blob(audioChunks, { type: 'audio/webm' });
                const arrayBuffer = await blob.arrayBuffer();
                const wavBlob = await convertToWav(arrayBuffer);

                recordBtn.disabled = true;
                statusDiv.innerText = '送信中';

                const formData = new FormData();
                formData.append("file", wavBlob, "recorded.wav");

                const response = await fetch('https://square-macaque-thankfully.ngrok-free.app/llm', {
                    method: 'POST',
                    body: formData
                });

                if (!response.body) {
                    statusDiv.innerText = 'エラー: 応答なし';
                    recordBtn.disabled = false;
                    return;
                }

                statusDiv.innerText = '受信中';
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let buffer = "", audioQueue = [];

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });

                    while (buffer.includes("\n")) {
                        const [line, ...rest] = buffer.split("\n");
                        buffer = rest.join("\n");
                        if (!line.trim()) continue;

                        try {
                            const data = JSON.parse(line);
                            if (data.input || data.text) {
                                const inputLine = data.input ? 'あなた: ' + data.input + '\n' : '';
                                const responseLine = data.text ? 'AI: ' + data.text + '\n\n' : '';
                                responseTextDiv.innerText = inputLine + responseLine + responseTextDiv.innerText;
                            }


                            if (data.voice) {
                                const binary = atob(data.voice);
                                const bytes = new Uint8Array(binary.length);
                                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                                audioQueue.push(new Blob([bytes], { type: 'audio/wav' }));
                            }
                        } catch (e) {
                            console.error('JSON parse error', e);
                            continue;
                        }
                    }
                }

                for (const blob of audioQueue) await playAudio(blob);
                statusDiv.innerText = '完了';
                recordBtn.disabled = false;
            };
            mediaRecorder.start();
        }

        function stopRecording() {
            mediaRecorder.stop();
        }

        async function playAudio(blob) {
            return new Promise((resolve) => {
                const audio = new Audio(URL.createObjectURL(blob));
                audio.onended = resolve;
                audio.onerror = resolve;
                audio.play();
            });
        }

        async function convertToWav(arrayBuffer) {
            const audioContext = new AudioContext();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            const samples = audioBuffer.getChannelData(0);
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            const writeString = (offset, str) => [...str].forEach((c, i) => view.setUint8(offset + i, c.charCodeAt(0)));

            writeString(0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true);
            writeString(8, 'WAVE'); writeString(12, 'fmt ');
            view.setUint32(16, 16, true); view.setUint16(20, 1, true);
            view.setUint16(22, 1, true); view.setUint32(24, audioBuffer.sampleRate, true);
            view.setUint32(28, audioBuffer.sampleRate * 2, true);
            view.setUint16(32, 2, true); view.setUint16(34, 16, true);
            writeString(36, 'data'); view.setUint32(40, samples.length * 2, true);

            let offset = 44;
            for (let s of samples) {
                const val = Math.max(-1, Math.min(1, s));
                view.setInt16(offset, val < 0 ? val * 0x8000 : val * 0x7FFF, true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        async function submitParams() {
            const speed = parseFloat(document.getElementById("speed").value);
            const volume = parseFloat(document.getElementById("volume").value);

            const response = await fetch('https://square-macaque-thankfully.ngrok-free.app/jtalk', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ speed, volume })
            });

            const result = await response.json();
            document.getElementById("param").textContent = `パラメータを変更しました: スピード=${result.speed}, ボリューム=${result.volume}`;
        }

        async function resetMessages() {
            const res = await fetch('https://square-macaque-thankfully.ngrok-free.app/init', { method: 'POST' });
            const result = await res.json();
            document.getElementById("initLog").textContent = "会話履歴を初期化しました。";
            inputTextDiv.innerText = '';
            responseTextDiv.innerText = '';
        }
    </script>
</body>
</html>
